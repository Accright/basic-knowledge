# IO模型及其基础
## 同步与异步
同步与异步主要用于区分多个任务同时进行时，是否需要逐个执行。同步任务需要逐个任务执行，异步任务可以多个任务同时执行。同步和异步类似于串行和并行的概念。示例代码如下：
同步代码：
```java
  void fun1() {
       
  }
   
  void fun2() {
       
  }
   
  void function(){
      fun1();
      fun2()
  }
```
异步代码：
```java
	void fun1() {
		 
	}
	 
	void fun2() {
		 
	}
	 
	void function(){
		new Thread(){
			public void run() {
				fun1();
			}
		}.start();
		 
		new Thread(){
			public void run() {
				fun2();
			}
		}.start();
	}
```
注意，异步任务和多线程不能简单的划等号，多线程是实现异步任务的一种方式。
## 阻塞与非阻塞
阻塞与非阻塞的区别在于访问一个任务时，如果没有对应资源是否等待直到资源满足。如果一直等待，则是阻塞的，此时其他的访问无法继续访问，因为有一个任务一直在等待，如果不等待直接返回一个结果，则是非阻塞。
阻塞与非阻塞和同步与异步不能划等号，同步与异步主要是针对多个任务的情况，阻塞与非阻塞主要用于对于同一个资源的访问时，可以类比于线程的阻塞来理解。
## 阻塞IO与非阻塞IO
通常来说，IO操作为对磁盘的读写，对Socket的读写，对外设的读写。
IO操作一般包括以下两个步骤：
1. 检查数据是否已经准备就绪
2. 进行数据的拷贝（将数据拷贝到用户线程从而进行操作）
阻塞IO在数据没有就绪的时候，会一直等待直到数据准备完毕，非阻塞IO则是直接返回一个无数据的标志，所以需要不断轮询查询。
JAVA中传统的IO都是阻塞IO，例如socket.read();
## 同步IO与异步IO
同步IO：用户请求IO操作会导致用户线程被阻塞；
异步IO：用户请求IO操作不会导致线程阻塞，IO的操作由内核进程完成。
异步IO必须有系统底层支持。
## 五种IO模型
### 阻塞IO
传统的IO模型，在IO操作时用户线程会阻塞。例如：data=socket.read();
### 非阻塞IO
不需要等待的IO模型，但是需要轮询获取数据（实际上可以采用多路复用IO的模式）。
### 多路复用IO模型
JAVA的NIO目前就是采用的多路复用IO，其思路是采用一个新的线程去不断轮询多个socket的状态，只有当socket有读写状态时，才调用实际的IO进行读写操作，轮询的操作是由内核的线程进行的，而且不断地对多个socket进行轮询，只有某个socket有IO事件时，才会占用资源进行读写操作，因此适合连接比较多的情况。
### 信号驱动模型
用户发起一个IO操作时，会给socket注册一个信号函数，然后用户线程继续执行，当内核数据就绪时，会发送一个信号给用户线程，用户线程接受到信号之后，便在信号函数中调用IO读写来执行IO操作。
### 异步IO模型
异步IO需要系统内核的支持，异步IO是用户线程发出一个IO请求之后，内核开始处理所有的IO数据检查和数据操作，完成之后给用户线程发送一个信号，用户线程直接调用即可。
# 两种高性能IO设计模式
## 经典设计模式：多线程设计模式
每一个socket的client都会创建一个线程用来建立连接，但是如果连接过多会导致线程数过大，资源占用非常大，因此提出了继续线程池的模式，原理见下图所示。但是如果client发的是长连接，会导致线程池中的线程得不到释放，会导致后续的客户端创建失败，因此这种设计模式适用于短连接较多的模式。为了解决多线程IO的弊端，有了以下两种高性能IO设计模式。
![多线程IO模式](https://images0.cnblogs.com/i/288799/201408/172148504055625.jpg)
## Reactor模式
Reactor模式就是多路复用IO的实现模式，创建一个专门的线程去轮询所有的IO事件，其原理可见下图所示：
![Reactor模式](https://images0.cnblogs.com/i/288799/201408/180940159566985.jpg)
## Proactor模式
异步IO模型采用的模式，会调用内核线程进行IO操作。