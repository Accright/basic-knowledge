# 几大排序算法
## 简介

### 介绍

排序算法一般分为内部排序和外部排序，内部排序即所有的数据加载到内存中，然后在内存中进行排序，如果数据量过大，一次性加载到内存将会耗费大量资源，需要内存和外存同时使用，即为外部排序，以下介绍的八大排序算法都为内部排序。

![排序算法分类](https://img-blog.csdn.net/20170905095722080)

### 分类

排序算法可以简单地分为以下几类，插入排序，选择排序，交换排序，归并排序，基数排序，其中插入排序还有直接插入排序和二分插入排序以及希尔排序，选择排序还有堆排序和简单选择排序，交换排序还有冒泡排序和快速排序，接下来我们将从基础的冒泡排序和快速排序开始，实现几大排序算法。

## 交换排序

### 冒泡排序

#### 基础思想

冒泡排序是对乱序的数组，自上而下地对相邻的两个数进行比较和调整，然后通过*交换*位置，使大的数下沉，小的数上冒。改进的冒泡排序则是从两端分别开始冒泡排序，使遍历的时间减少了一半。

#### 示例图

![冒泡排序](https://img-blog.csdn.net/20170905170411607)

#### 代码

```java
//冒泡排序
public void bubbleSort(int[] x){
	for (int i = 0;i < x.length; i++){
		for (int j = 0;j < x.length - i - 1;j++){
			if (x[j] > x[j+1]){
				swap(j,j+1,x);
			}
		}
	}
}
```

### 快速排序

#### 基础思想

快速排序用了递归的思想，在给定的乱序数组中，取一个基准值，将数组一分为二，然后再递归此方法，分别排序基准值左侧和右侧的数。

#### 示例图

![快速排序](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

#### 代码

```java
//快排的recursive
public void quickSort(int x[],int low,int high){
	if (low < high){
		int middle = this.getKey(x,low,high);
		this.quickSort(x,0,middle - 1);
		this.quickSort(x,middle + 1,high);
	}
}

//快排 交换并返回目前的基准值
public int getKey(int[] x,int low,int high){
	int temp = x[low];
	while (low < high){
		while (low < high && x[high] >= temp){
			high --;
		}
		x[low] = x[high];
		while (low < high && x[low] <= temp){
			low ++;
		}
		x[high] = x[low];
	}
	x[low] = temp;
	return low;
}
```

## 插入排序

### 直接插入排序

#### 基础思想

遍历乱序的数组，每步将一个待排序的记录，通过比较的方式，找到合适的插入位置，保证插入位置前的数组是有序的。

#### 示例图

![直接插入排序](https://img-blog.csdn.net/20170905145340969)

#### 代码

```java
//冒泡排序
public void bubbleSort(int[] x){
	for (int i = 0;i < x.length; i++){
		for (int j = 0;j < x.length - i - 1;j++){
			if (x[j] > x[j+1]){
				swap(j,j+1,x);
			}
		}
	}
}
```

